<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Test Audio Core ‚Äî Pitch Detection + Recording</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root {
  --bg: #0b1220;
  --panel: #0e1729;
  --card: #111a2e;
  --grid: #1a2642;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --ok: #10b981;
  --err: #ef4444;
  --blue: #3b82f6;
  --green: #22c55e;
  --orange: #f59e0b;
}

* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; }
body {
  background: var(--bg);
  color: var(--text);
  font: 14px/1.45 system-ui, Segoe UI, Roboto, Arial;
  padding: 0;
}

.wrap {
  max-width: 1400px;
  margin: 20px auto;
  padding: 0 16px;
}

.h1 {
  font-weight: 800;
  font-size: 20px;
  margin: 0 0 16px 0;
}

.h2 {
  font-weight: 700;
  font-size: 14px;
  margin: 0 0 8px 0;
}

.bar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  margin-bottom: 12px;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 1px solid #1f2a44;
  background: var(--card);
  color: var(--text);
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 13px;
  transition: all 0.2s;
}

.btn:hover:not([disabled]) {
  background: #16213a;
  border-color: #2a3a54;
}

.btn[disabled] {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn.ok {
  background: #0e1f14;
  border-color: #173621;
  color: #c8facc;
}

.btn.err {
  background: #2a0f14;
  border-color: #4a171f;
  color: #fecaca;
}

.seg {
  display: inline-flex;
  border: 1px solid #22304f;
  background: var(--card);
  border-radius: 8px;
  overflow: hidden;
}

.seg button {
  padding: 8px 12px;
  border: 0;
  background: transparent;
  color: var(--text);
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
}

.seg button.active {
  background: #16213a;
  color: #22c55e;
}

.timer {
  padding: 8px 12px;
  border: 1px solid #22304f;
  border-radius: 8px;
  background: var(--card);
  min-width: 60px;
  text-align: center;
  font-weight: 600;
  font-family: monospace;
}

.cols {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 16px;
}

@media (max-width: 1024px) {
  .cols {
    grid-template-columns: 1fr;
  }
}

.panel {
  background: var(--panel);
  border: 1px solid #1f2a44;
  border-radius: 12px;
  padding: 16px;
}

.canvasWrap {
  border: 1px solid #1f2a44;
  border-radius: 8px;
  padding: 4px;
  background: #0b1324;
  margin: 8px 0;
}

canvas {
  display: block;
  width: 100%;
  height: auto;
  background: #0b1324;
}

.controls {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.log {
  background: #0b1020;
  border: 1px solid #1f2a44;
  border-radius: 8px;
  padding: 12px;
  color: #dbeafe;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 12px;
  max-height: 250px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}

.badge {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  border: 1px solid #22304f;
  background: #0b1220;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 12px;
}

.badge.ok {
  color: #bbf7d0;
  border-color: #206a44;
  background: #052216;
}

.badge.warn {
  color: #fde68a;
  border-color: #6b4d11;
  background: #261a06;
}

.hint {
  color: var(--muted);
  font-size: 12px;
  margin: 6px 0 8px 0;
}

.right {
  margin-left: auto;
}

input[type="file"] {
  padding: 8px 12px;
  border: 1px solid #22304f;
  border-radius: 8px;
  background: #0f172a;
  color: var(--text);
  font-size: 13px;
}

.metrics {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 8px;
  font-size: 12px;
}

.metric {
  background: #0b1220;
  border: 1px solid #22304f;
  border-radius: 6px;
  padding: 6px 10px;
}

.debugInfo {
  background: #0b1020;
  border: 1px solid #22304f;
  border-radius: 6px;
  padding: 6px 10px;
  font-size: 11px;
  color: #cbd5e1;
  margin-top: 8px;
}
</style>
</head>
<body>

<!-- TONE.JS CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<!-- YIN DETECTOR (d√©tection brute) -->
<script src="./src/vendor/yin-detector.js"></script>

<!-- PITCH SMOOTHER (lissage) -->
<script src="./src/utils/pitch-smoothing.js"></script>

<div class="wrap">
  <div class="h1">üéµ Test Audio Core ‚Äî Enregistrement + D√©tection Pitch (LISS√âE)</div>

  <div class="bar">
    <button id="btnMic" class="btn">üé§ Activer micro</button>

    <div class="seg">
      <button id="btnRecStart" class="btn">‚ñ∂ Enregistrer</button>
      <button id="btnRecStop" class="btn err" disabled>‚èπ Stop</button>
    </div>

    <div class="timer" id="timerRec">00:00</div>

    <div class="seg">
      <button id="btnMonOff" class="btn active">Moniteur OFF</button>
      <button id="btnMonOn" class="btn">Moniteur ON</button>
    </div>

    <span class="right badge warn" id="pitchyStatus">D√©tecteur: chargement...</span>
  </div>

  <div class="cols">
    <div class="panel">
      <p class="h2">üéôÔ∏è Ta prise (micro)</p>
      <div class="hint">Courbe bleue = ton pitch liss√©. Ligne verte = 0 cent (440 Hz).</div>
      <div class="canvasWrap">
        <canvas id="canvasRec" width="600" height="320"></canvas>
      </div>
      <div class="debugInfo" id="debugRec">D√©tections brutes: 0 | Points liss√©s: 0</div>
      <div class="controls">
        <button id="btnDownWebM" class="btn">‚¨áÔ∏è WebM</button>
        <button id="btnDownWAV" class="btn">üéß WAV</button>
        <button id="btnDownMP3" class="btn">üéµ MP3</button>
        <button id="btnClearRec" class="btn">üóëÔ∏è Effacer</button>
        <input type="file" id="fileUploadRec" accept="audio/*" class="btn" style="border:1px solid #22304f;padding:8px 12px;cursor:pointer" />
      </div>
    </div>

    <div class="panel">
      <p class="h2">üéº R√©f√©rence (comparaison)</p>
      <div class="hint">Charge un MP3/WAV local pour comparer ta courbe.</div>
      <div class="canvasWrap">
        <canvas id="canvasRef" width="600" height="320"></canvas>
      </div>
      <div class="debugInfo" id="debugRef">D√©tections brutes: 0 | Points liss√©s: 0</div>
      <div class="controls">
        <input type="file" id="fileUploadRef" accept="audio/*" class="btn" style="border:1px solid #22304f;padding:8px 12px;cursor:pointer" />
        <button id="btnClearRef" class="btn">üóëÔ∏è Effacer</button>
      </div>
      <div class="metrics" id="metricsRef">
        <div class="metric">√âcart moy: <b id="mAvg">‚Äî</b></div>
        <div class="metric">√âcart max: <b id="mMax">‚Äî</b></div>
        <div class="metric">% juste: <b id="mInTune">‚Äî</b></div>
      </div>
    </div>
  </div>

  <div class="h1">üìã Logs</div>
  <div id="logBox" class="log">D√©marrage...</div>
</div>

<script src="./src/vendor/pitchy-lite.js"></script>
<script src="./src/utils/wav-export.js"></script>
<script src="./src/utils/mp3-export.js"></script>

<script>
/* ==================== LOGGER ==================== */
const logBox = document.getElementById('logBox');
const log = (level, msg) => {
  const now = new Date();
  const h = String(now.getHours()).padStart(2, '0');
  const m = String(now.getMinutes()).padStart(2, '0');
  const s = String(now.getSeconds()).padStart(2, '0');
  const line = `[${h}:${m}:${s}] [${level}] ${msg}`;
  logBox.textContent += line + '\n';
  logBox.scrollTop = logBox.scrollHeight;
};

/* ==================== STATE ==================== */
let audioCtx = null;
let analyser = null;
let micStream = null;
let mediaRecorder = null;
let chunks = [];
let lastBlob = null;
let detector = null;
let smoother = null; // ‚Üê NOUVEAU: Instance du PitchSmoother
let recordedPitch = [];
let recordedPitchSmoothed = []; // ‚Üê NOUVEAU: Pitch liss√©
let recordDetectionCount = 0;
let recordDetectionRawCount = 0; // ‚Üê NOUVEAU: D√©tections brutes
let recStart = 0;
let timerInterval = null;
let rafId = null;
let monitorOn = false;

let refData = { pitch: [], duration: 0 };
let refDetectionCount = 0;

const canvasRec = document.getElementById('canvasRec');
const ctxRec = canvasRec.getContext('2d');
const canvasRef = document.getElementById('canvasRef');
const ctxRef = canvasRef.getContext('2d');

const btnMic = document.getElementById('btnMic');
const btnRecStart = document.getElementById('btnRecStart');
const btnRecStop = document.getElementById('btnRecStop');
const timerRec = document.getElementById('timerRec');
const btnMonOff = document.getElementById('btnMonOff');
const btnMonOn = document.getElementById('btnMonOn');
const pitchyStatus = document.getElementById('pitchyStatus');
const debugRec = document.getElementById('debugRec');
const debugRef = document.getElementById('debugRef');
const mAvg = document.getElementById('mAvg');
const mMax = document.getElementById('mMax');
const mInTune = document.getElementById('mInTune');
const fileUploadRec = document.getElementById('fileUploadRec');
const fileUploadRef = document.getElementById('fileUploadRef');
const btnDownWebM = document.getElementById('btnDownWebM');
const btnDownWAV = document.getElementById('btnDownWAV');
const btnDownMP3 = document.getElementById('btnDownMP3');
const btnClearRec = document.getElementById('btnClearRec');
const btnClearRef = document.getElementById('btnClearRef');

/* ==================== CANVAS HELPERS ==================== */
function drawCanvasRec() {
  const w = canvasRec.width;
  const h = canvasRec.height;
  ctxRec.fillStyle = '#0b1324';
  ctxRec.fillRect(0, 0, w, h);

  ctxRec.strokeStyle = '#22304f';
  ctxRec.lineWidth = 1;
  ctxRec.beginPath();
  ctxRec.moveTo(0, h / 2);
  ctxRec.lineTo(w, h / 2);
  ctxRec.stroke();

  for (let i = 0; i < 5; i++) {
    const y = (h / 4) * i;
    ctxRec.strokeStyle = '#1a2642';
    ctxRec.lineWidth = 0.5;
    ctxRec.beginPath();
    ctxRec.moveTo(0, y);
    ctxRec.lineTo(w, y);
    ctxRec.stroke();
  }

  ctxRec.strokeStyle = '#10b981';
  ctxRec.lineWidth = 2;
  ctxRec.setLineDash([4, 4]);
  ctxRec.beginPath();
  ctxRec.moveTo(0, h / 2);
  ctxRec.lineTo(w, h / 2);
  ctxRec.stroke();
  ctxRec.setLineDash([]);

  ctxRec.fillStyle = '#9ca3af';
  ctxRec.font = '11px monospace';
  ctxRec.textAlign = 'right';
  ctxRec.fillText('60c', 55, 16);
  ctxRec.textAlign = 'left';
  ctxRec.fillText('-60c', 65, 16);
}

function drawCanvasRef() {
  const w = canvasRef.width;
  const h = canvasRef.height;
  ctxRef.fillStyle = '#0b1324';
  ctxRef.fillRect(0, 0, w, h);

  ctxRef.strokeStyle = '#22304f';
  ctxRef.lineWidth = 1;
  ctxRef.beginPath();
  ctxRef.moveTo(0, h / 2);
  ctxRef.lineTo(w, h / 2);
  ctxRef.stroke();

  for (let i = 0; i < 5; i++) {
    const y = (h / 4) * i;
    ctxRef.strokeStyle = '#1a2642';
    ctxRef.lineWidth = 0.5;
    ctxRef.beginPath();
    ctxRef.moveTo(0, y);
    ctxRef.lineTo(w, y);
    ctxRef.stroke();
  }

  ctxRef.strokeStyle = '#10b981';
  ctxRef.lineWidth = 2;
  ctxRef.setLineDash([4, 4]);
  ctxRef.beginPath();
  ctxRef.moveTo(0, h / 2);
  ctxRef.lineTo(w, h / 2);
  ctxRef.stroke();
  ctxRef.setLineDash([]);

  ctxRef.fillStyle = '#9ca3af';
  ctxRef.font = '11px monospace';
  ctxRef.textAlign = 'right';
  ctxRef.fillText('60c', 55, 16);
  ctxRef.textAlign = 'left';
  ctxRef.fillText('-60c', 65, 16);
}

function mapCentsToY(cents, height) {
  const centsPerPixel = 120 / (height - 80);
  const midY = height / 2;
  return midY - (cents / centsPerPixel);
}

function hzToCents(hz, ref = 440) {
  if (hz <= 0) return 0;
  return 1200 * Math.log2(hz / ref);
}

/* ==================== AUDIO INIT ==================== */
async function ensureAudio() {
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      log('INFO', 'AudioContext cr√©√©');
    } catch (err) {
      log('ERROR', 'AudioContext: ' + err.message);
      throw err;
    }
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
    log('INFO', 'AudioContext repris');
  }
}

async function activateMic() {
  try {
    await ensureAudio();

    if (!micStream) {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log('INFO', 'Microphone autoris√©');
    }

    if (!analyser) {
      const src = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      src.connect(analyser);
      log('INFO', 'Analyser connect√©');
    }

    btnMic.disabled = true;
    btnRecStart.disabled = false;

    if (!detector) initDetector();
    if (!smoother) initSmoother(); // ‚Üê NOUVEAU: Initialiser le smoother

  } catch (err) {
    log('ERROR', 'Mic: ' + err.message);
  }
}

/* ==================== PITCH DETECTION (NOUVEAU) ==================== */
function initDetector() {
  if (typeof PitchyLite === 'undefined') {
    log('ERROR', 'PitchyLite non disponible');
    pitchyStatus.textContent = 'D√©tecteur: ERREUR';
    pitchyStatus.className = 'badge err';
    return false;
  }

  detector = new PitchyLite(audioCtx.sampleRate);
  log('INFO', 'D√©tecteur pitch (PitchyLite) initialis√©');
  pitchyStatus.textContent = 'D√©tecteur: OK';
  pitchyStatus.className = 'badge ok';
  return true;
}

/* ==================== PITCH SMOOTHER (NOUVEAU) ==================== */
function initSmoother() {
  if (typeof PitchSmoother === 'undefined') {
    log('WARN', 'PitchSmoother non disponible - utilisation d√©tections brutes');
    return false;
  }

  try {
    smoother = new PitchSmoother({
      medianSize: 5,
      smoothingFactor: 0.7,
      jumpThreshold: 1.5
    });
    log('INFO', 'PitchSmoother initialis√© (m√©dian + EMA + validation)');
    return true;
  } catch (err) {
    log('WARN', 'PitchSmoother init failed: ' + err.message);
    return false;
  }
}

/* ==================== RECORDING ==================== */
function updateTimer(secs) {
  const mm = String(Math.floor(secs / 60)).padStart(2, '0');
  const ss = String(Math.floor(secs % 60)).padStart(2, '0');
  timerRec.textContent = `${mm}:${ss}`;
}

function startRecording() {
  if (!micStream) {
    log('WARN', 'Activez d\'abord le micro');
    return;
  }

  if (!detector) {
    initDetector();
  }

  if (!smoother) {
    initSmoother();
  }

  chunks = [];
  lastBlob = null;
  recordedPitch = [];
  recordedPitchSmoothed = []; // ‚Üê NOUVEAU: Reset
  recordDetectionCount = 0;
  recordDetectionRawCount = 0; // ‚Üê NOUVEAU: Reset
  recStart = audioCtx.currentTime;

  const options = {
    mimeType: 'audio/webm;codecs=opus',
    audioBitsPerSecond: 128000,
  };

  mediaRecorder = new MediaRecorder(micStream, options);
  mediaRecorder.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) {
      chunks.push(e.data);
    }
  };
  mediaRecorder.onstop = () => {
    if (chunks.length > 0) {
      lastBlob = new Blob(chunks, { type: 'audio/webm' });
      log('INFO', 'Enregistrement termin√©');
    }
  };

  mediaRecorder.start(100);
  btnRecStart.disabled = true;
  btnRecStop.disabled = false;

  timerInterval = setInterval(() => {
    const elapsed = audioCtx.currentTime - recStart;
    updateTimer(elapsed);
  }, 100);

  log('INFO', 'Enregistrement d√©marr√©');
  startMonitor();
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
    btnRecStart.disabled = false;
    btnRecStop.disabled = true;
    clearInterval(timerInterval);
    updateTimer(0);
    stopMonitor();
  }
}

/* ==================== MONITOR LIVE (MODIFI√â) ==================== */
function startMonitor() {
  if (!detector || !analyser) return;
  if (rafId) return;

  const buf = new Float32Array(analyser.fftSize);

  function tick() {
    drawCanvasRec();

    analyser.getFloatTimeDomainData(buf);
    const hz = detector.detect(buf);

    if (hz && hz > 0) {
      recordDetectionRawCount++; // ‚Üê NOUVEAU: Compter d√©tections brutes

      // ‚Üê NOUVEAU: Passer par le smoother
      let smoothedHz = hz;
      if (smoother) {
        smoothedHz = smoother.smooth(hz);   // ‚úÖ CORRECT
      }

      const cents = hzToCents(smoothedHz, 440);
      const elapsed = audioCtx.currentTime - recStart;
      const x = 60 + (canvasRec.width - 80) * Math.min(elapsed / 120, 1);
      const y = mapCentsToY(cents, canvasRec.height);

      recordedPitch.push({ t: elapsed, hz: smoothedHz, cents, x, y }); // ‚Üê Liss√©
      recordDetectionCount++;

      if (recordedPitch.length > 1) {
        const prev = recordedPitch[recordedPitch.length - 2];
        ctxRec.strokeStyle = '#3b82f6';
        ctxRec.lineWidth = 2;
        ctxRec.beginPath();
        ctxRec.moveTo(prev.x, prev.y);
        ctxRec.lineTo(x, y);
        ctxRec.stroke();
      }

      ctxRec.fillStyle = '#3b82f6';
      ctxRec.beginPath();
      ctxRec.arc(x, y, 2.5, 0, Math.PI * 2);
      ctxRec.fill();
    }

    // ‚Üê NOUVEAU: Afficher d√©tections brutes vs liss√©es
    debugRec.textContent = `D√©tections brutes: ${recordDetectionRawCount} | Points liss√©s: ${recordDetectionCount}`;

    if (monitorOn || (mediaRecorder && mediaRecorder.state === 'recording')) {
      rafId = requestAnimationFrame(tick);
    }
  }

  tick();
}

function stopMonitor() {
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }
  drawCanvasRec();
}

/* ==================== EXPORTS ==================== */
function downloadBlob(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  log('INFO', `T√©l√©charg√©: ${name}`);
}

btnDownWebM.onclick = () => {
  if (!lastBlob) return log('WARN', 'Aucun enregistrement');
  downloadBlob(lastBlob, 'take.webm');
};

btnDownWAV.onclick = async () => {
  if (!lastBlob) return log('WARN', 'Aucun enregistrement');
  if (!window.WAVExport) return log('ERROR', 'WAVExport indisponible');
  const wav = await WAVExport.fromWebM(lastBlob);
  if (!wav) return log('ERROR', 'Conversion WAV √©chou√©e');
  downloadBlob(wav, 'take.wav');
};

btnDownMP3.onclick = async () => {
  if (!lastBlob) return log('WARN', 'Aucun enregistrement');
  if (!window.WAVExport) return log('ERROR', 'WAVExport indisponible');
  if (!window.MP3Export) return log('ERROR', 'MP3Export indisponible');

  try {
    const wav = await WAVExport.fromWebM(lastBlob);
    if (!wav) return log('ERROR', 'Conversion WAV √©chou√©e');
    log('INFO', 'Encodage MP3 en cours...');
    const mp3 = await MP3Export.fromWav(wav);
    if (!mp3) return log('ERROR', 'Conversion MP3 √©chou√©e');
    downloadBlob(mp3, 'take.mp3');
  } catch (err) {
    log('ERROR', 'MP3: ' + err.message);
  }
};

btnClearRec.onclick = () => {
  chunks = [];
  lastBlob = null;
  recordedPitch = [];
  recordedPitchSmoothed = [];
  recordDetectionCount = 0;
  recordDetectionRawCount = 0;
  updateTimer(0);
  drawCanvasRec();
  debugRec.textContent = 'D√©tections brutes: 0 | Points liss√©s: 0';
  log('INFO', 'Enregistrement effac√©');
};

/* ==================== FILE UPLOADS ==================== */
fileUploadRec.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    await ensureAudio();
    const buf = await file.arrayBuffer();
    lastBlob = new Blob([buf], { type: file.type });
    chunks = [new Blob([buf], { type: file.type })];
    log('INFO', `Fichier charg√©: ${file.name}`);
  } catch (err) {
    log('ERROR', 'Upload rec: ' + err.message);
  }
});

fileUploadRef.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    await ensureAudio();
    const buf = await file.arrayBuffer();
    const audio = await audioCtx.decodeAudioData(buf);
    const ch = audio.getChannelData(0);
    refData.duration = audio.duration;
    refDetectionCount = 0;
    refData.pitch = extractPitch(ch, audio.sampleRate);
    drawReferenceData();
    log('INFO', `R√©f√©rence charg√©e: ${file.name} (${audio.duration.toFixed(1)}s, ${refData.pitch.length} points)`);
  } catch (err) {
    log('ERROR', 'Upload ref: ' + err.message);
  }
});

btnClearRef.onclick = () => {
  refData = { pitch: [], duration: 0 };
  refDetectionCount = 0;
  drawCanvasRef();
  debugRef.textContent = 'D√©tections brutes: 0 | Points liss√©s: 0';
  log('INFO', 'R√©f√©rence effac√©e');
};

/* ==================== PITCH EXTRACTION (MODIFI√â) ==================== */
function extractPitch(samples, sr) {
  if (!detector) return [];

  const result = [];
  const win = 2048;
  const hop = 512;
  let detectionCount = 0;
  let rawCount = 0;

  // ‚Üê NOUVEAU: R√©initialiser le smoother pour la r√©f√©rence
  if (smoother) {
    smoother.reset();
  }

  for (let i = 0; i + win <= samples.length; i += hop) {
    const slice = samples.subarray(i, i + win);
    const hz = detector.detect(slice);
    if (hz && hz > 0) {
      rawCount++;

      // ‚Üê NOUVEAU: Lisser via smoother
      let smoothedHz = hz;
      if (smoother) {
        smoothedHz = smoother.smooth(hz);   // ‚úÖ CORRECT
      }

      detectionCount++;
      const t = i / sr;
      const cents = hzToCents(smoothedHz, 440);
      result.push({ t, hz: smoothedHz, cents });
    }
  }

  refDetectionCount = detectionCount;
  log('INFO', `Extraction r√©f√©rence: ${rawCount} d√©tections brutes ‚Üí ${detectionCount} points liss√©s`);
  return result;
}

/* ==================== REFERENCE DRAWING ==================== */
function drawReferenceData() {
  drawCanvasRef();

  if (refData.pitch.length === 0) {
    debugRef.textContent = 'D√©tections brutes: 0 | Points liss√©s: 0';
    return;
  }

  const w = canvasRef.width;
  const h = canvasRef.height;

  ctxRef.strokeStyle = '#a78bfa';
  ctxRef.lineWidth = 2;
  ctxRef.beginPath();

  let first = true;
  for (const p of refData.pitch) {
    const x = 60 + (w - 80) * (p.t / Math.max(refData.duration, 1));
    const y = mapCentsToY(p.cents, h);

    if (first) {
      ctxRef.moveTo(x, y);
      first = false;
    } else {
      ctxRef.lineTo(x, y);
    }
  }

  ctxRef.stroke();

  debugRef.textContent = `D√©tections brutes: ? | Points liss√©s: ${refData.pitch.length}`;

  if (refData.pitch.length > 0) {
    const devs = refData.pitch.map(p => Math.abs(p.cents));
    const avg = devs.reduce((a, b) => a + b, 0) / devs.length;
    const max = Math.max(...devs);
    const inTune = refData.pitch.filter(p => Math.abs(p.cents) < 25).length / refData.pitch.length * 100;

    mAvg.textContent = avg.toFixed(1) + 'c';
    mMax.textContent = max.toFixed(1) + 'c';
    mInTune.textContent = inTune.toFixed(1) + '%';
  }
}

/* ==================== EVENTS ==================== */
btnMic.onclick = () => activateMic();
btnRecStart.onclick = () => startRecording();
btnRecStop.onclick = () => stopRecording();

btnMonOff.onclick = () => {
  monitorOn = false;
  btnMonOff.classList.add('active');
  btnMonOn.classList.remove('active');
  stopMonitor();
  log('INFO', 'Moniteur OFF');
};

btnMonOn.onclick = () => {
  monitorOn = true;
  btnMonOn.classList.add('active');
  btnMonOff.classList.remove('active');
  if (audioCtx) startMonitor();
  log('INFO', 'Moniteur ON');
};

log('INFO', 'Interface pr√™te - Lissage YIN+Smoother activ√©');
</script>

</body>
</html>
