<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Test Audio Core + Pitch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--bg:#f7f7fb;--card:#fff;--text:#1f2937;--muted:#6b7280;--ok:#16a34a;--warn:#d97706;--err:#dc2626;--blue:#4f46e5;}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:900px;margin:24px auto;padding:16px}
    .title{font-size:24px;font-weight:800;margin:8px 0 4px}
    .subtitle{color:var(--muted);margin:0 0 20px}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 2px 8px rgba(0,0,0,.06);margin:12px 0}
    .row{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .kv{border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .kv b{display:block;color:var(--muted);font-weight:600;margin-bottom:6px}
    .badge{display:inline-flex;align-items:center;gap:8px;background:#e8f6ef;color:var(--ok);border:1px solid #b7e4c7;padding:8px 12px;border-radius:10px;font-weight:600}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
    .b1{background:#e5e7eb;color:#111827}
    .b2{background:#111827;color:#fff}
    .b3{background:#e11d48;color:#fff}
    .b4{background:#10b981;color:#fff}
    .b1[disabled],.b2[disabled],.b3[disabled]{opacity:.45;cursor:not-allowed}
    pre{background:#0b1020;color:#dbeafe;border-radius:10px;padding:12px;max-height:320px;overflow:auto}
    .ok{color:var(--ok)} .err{color:var(--err)} .muted{color:var(--muted)}
    /* Scopes */
    #scope{width:100%;height:160px;background:#0b1020;border-radius:10px;display:block}
    #pitch{width:100%;height:160px;background:#0b1020;border-radius:10px;display:block}
    .pill{display:inline-block;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;padding:6px 10px;border-radius:999px;font-weight:700}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">🎤 Test Audio Core</div>
    <p class="subtitle">Test des modules de base du système audio + détection de hauteur (pitch)</p>

    <div class="card">
      <div class="badge">🔒 Protocole détecté : <span id="protoTxt" style="margin-left:6px">—</span></div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:6px">✅ Statut du Système</div>
      <div id="sysStatus" class="muted">En attente… cliquez sur “Initialiser”.</div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">🎛️ AudioContext</div>
      <div class="row">
        <div class="kv"><b>ÉTAT</b><span id="ctxState">—</span></div>
        <div class="kv"><b>SAMPLE RATE</b><span id="ctxRate">—</span></div>
        <div class="kv"><b>BASE LATENCY</b><span id="ctxLatency">—</span></div>
        <div class="kv"><b>CURRENT TIME</b><span id="ctxTime">—</span></div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">🧭 Navigateur</div>
      <div class="row">
        <div class="kv"><b>NAVIGATEUR</b><span id="navName">—</span></div>
        <div class="kv"><b>VERSION</b><span id="navVer">—</span></div>
        <div class="kv"><b>OS</b><span id="navOS">—</span></div>
        <div class="kv"><b>MOBILE</b><span id="navMob">—</span></div>
      </div>
    </div>

    <div class="btns">
      <button class="b4" id="btnInit">✅ Initialiser</button>
      <button class="b2" id="btnMic" disabled>🎤 Tester Microphone</button>
      <button class="b2" id="btnRec" disabled>🎙️ Enregistrer 5s</button>
      <button class="b3" id="btnDestroy" disabled>🧨 Détruire</button>
      <button class="b1" id="btnClear">🧹 Effacer Logs</button>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">Console</div>
      <pre id="logBox">Système de logs prêt…</pre>
    </div>

    <div class="card">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px">
        <div style="font-weight:800">Oscilloscope (forme d’onde)</div>
      </div>
      <canvas id="scope" width="800" height="160"></canvas>
    </div>

    <div class="card">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px">
        <div style="font-weight:800">Pitch (note + cents) — ligne médiane = 0 cent (référence)</div>
        <div class="pill" id="pitchInfo">—</div>
      </div>
      <canvas id="pitch" width="800" height="160"></canvas>
    </div>
  </div>

  <script type="module">
    import AudioEngine from './src/audio/core/AudioEngine.js';
    import { Logger } from './src/logging/Logger.js';
    import MicrophoneManager from './src/audio/core/MicrophoneManager.js';
    import BrowserDetector from './src/utils/BrowserDetector.js';
    import './src/audio/core/ErrorHandler.js';
    import { CONFIG } from './src/config.js';

    // --- UI refs
    const logBox = document.getElementById('logBox');
    const btnInit = document.getElementById('btnInit');
    const btnMic = document.getElementById('btnMic');
    const btnRec = document.getElementById('btnRec');
    const btnDestroy = document.getElementById('btnDestroy');
    const btnClear = document.getElementById('btnClear');
    const protoTxt = document.getElementById('protoTxt');
    const sysStatus = document.getElementById('sysStatus');
    const ctxState = document.getElementById('ctxState');
    const ctxRate  = document.getElementById('ctxRate');
    const ctxLatency = document.getElementById('ctxLatency');
    const ctxTime  = document.getElementById('ctxTime');
    const navName = document.getElementById('navName');
    const navVer  = document.getElementById('navVer');
    const navOS   = document.getElementById('navOS');
    const navMob  = document.getElementById('navMob');
    const scope = document.getElementById('scope');
    const pitchCanvas = document.getElementById('pitch');
    const glScope = scope.getContext('2d');
    const glPitch = pitchCanvas.getContext('2d');
    const pitchInfo = document.getElementById('pitchInfo');

    function addLog(line){ const now=new Date().toTimeString().slice(0,8); logBox.textContent+=`\n[${now}] ${line}`; logBox.scrollTop=logBox.scrollHeight; }
    Logger.setExternalSink?.((level, scope, msg, data)=>{ const d=data?` | ${JSON.stringify(data)}`:''; addLog(`[${level}] [${scope}] ${msg}${d}`); });

    // --- State
    let audioEngine=null, micManager=null, ctxInterval=null, analyser=null, mediaRecorder=null;
    let drawRAF1=null, drawRAF2=null, pitchArray=[]; // pitch points for timeline

    // --- DPR fit
    function fitCanvasDPR(canvas, gl){
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      gl.setTransform(dpr,0,0,dpr,0,0);
    }
    function fitAll(){ fitCanvasDPR(scope, glScope); fitCanvasDPR(pitchCanvas, glPitch); }
    fitAll(); addEventListener('resize', fitAll);

    // --- Boot: protocol & browser
    (function boot(){
      const https = location.protocol==='https:' || location.hostname==='localhost';
      protoTxt.textContent = https ? 'HTTPS (sécurisé)' : 'HTTP (non sécurisé)';
      protoTxt.style.color = https ? 'var(--ok)' : 'var(--err)';
      const b = BrowserDetector.detect();
      navName.textContent=b?.name??'—'; navVer.textContent=b?.fullVersion??(b?.version??'—'); navOS.textContent=b?.os??'—'; navMob.textContent=b?.mobile?'Oui':'Non';
      Logger.info('Test','📱 Page chargée');
      Logger.info('Protocol', https ? 'HTTPS détecté - Microphone accessible' : 'HTTP détecté - Activer HTTPS pour le micro');
      Logger.info('BrowserDetector','Détection du navigateur...');
      Logger.info('BrowserDetector',`${b?.name??'?'} ${b?.fullVersion??b?.version??''} sur ${b?.os??'?'}`, b);
      const report = BrowserDetector.getCompatibilityReport?.() ?? { browser:b, features:{ AudioContext:!!(window.AudioContext||window.webkitAudioContext), getUserMedia:!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia), MediaRecorder:'MediaRecorder'in window, AnalyserNode:!!(window.AudioContext||window.webkitAudioContext), localStorage:'localStorage'in window, WebAudio:!!(window.AudioContext||window.webkitAudioContext)}, recommendations:[], warnings:[] };
      Logger.info('BrowserDetector','Rapport de compatibilité généré', report);
    })();

    // --- Ticker panneau AudioContext
    function startContextTicker(ctx){
      stopContextTicker();
      ctxInterval=setInterval(()=>{ try{
        ctxState.textContent=ctx?.state??'—';
        ctxRate.textContent=`${ctx?.sampleRate??0} Hz`;
        const base=typeof ctx?.baseLatency==='number'?ctx.baseLatency:0;
        ctxLatency.textContent=`${(base*1000).toFixed(2)} ms`;
        ctxTime.textContent=`${(ctx?.currentTime??0).toFixed(2)} s`;
      }catch{} },250);
    }
    function stopContextTicker(){ if(ctxInterval){ clearInterval(ctxInterval); ctxInterval=null; } }

    // --- Utils: freq→note/cents
    const A4 = 440;
    const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    function freqToNoteData(freq){
      if (!freq || !isFinite(freq)) return {note:'—',oct:'-', cents:0, midi:null};
      const midi = 69 + 12*Math.log2(freq/A4);
      const nearest = Math.round(midi);
      const cents = Math.round((midi - nearest) * 100);
      const noteIndex = (nearest + 1200) % 12;
      const note = noteNames[noteIndex];
      const oct = Math.floor(nearest/12) - 1;
      return {note, oct, cents, midiNearest: nearest, freq, midi};
    }

    // --- Pitch detection (YIN simplifié / autocorr)
    function detectPitchYIN(buf, sampleRate){
      const N = buf.length;
      // 1) difference function d(tau)
      const tauMax = Math.min(Math.floor(sampleRate/50), N-1);   // ~50 Hz bas
      const tauMin = Math.max(2, Math.floor(sampleRate/1000));   // ~1000 Hz haut
      const diff = new Float32Array(tauMax+1);
      for (let tau=tauMin; tau<=tauMax; tau++){
        let sum=0;
        for (let i=0; i<N-tau; i++){
          const d = buf[i]-buf[i+tau];
          sum += d*d;
        }
        diff[tau]=sum;
      }
      // 2) cumulative mean normalized difference (CMND)
      const cmnd = new Float32Array(tauMax+1);
      let running=0;
      for (let tau=tauMin; tau<=tauMax; tau++){
        running += diff[tau];
        cmnd[tau] = diff[tau] * tau / (running || 1);
      }
      // 3) pick first minimum below threshold
      const thresh=0.12;
      let tau=tauMin;
      for (; tau<=tauMax; tau++){
        if (cmnd[tau] < thresh){
          // refine: local minimum
          while (tau+1<=tauMax && cmnd[tau+1] < cmnd[tau]) tau++;
          break;
        }
      }
      if (tau>tauMax) return {freq:null, conf:0};
      // 4) parabolic interpolation around tau
      const x0 = (tau<=1)? tau : tau-1;
      const x2 = (tau+1<=tauMax)? tau+1 : tau;
      const y0 = cmnd[x0], y1 = cmnd[tau], y2 = cmnd[x2];
      const denom = (y0 + y2 - 2*y1);
      const betterTau = tau + (denom ? ( (y0 - y2) / (2*denom) ) : 0);
      const freq = sampleRate / betterTau;
      const conf = 1 - y1;
      return {freq, conf};
    }

    // --- Drawing: oscilloscope
    function drawScope(){
      if (!analyser) return;
      const N = analyser.fftSize;
      const data = new Float32Array(N);
      analyser.getFloatTimeDomainData(data);
      const W = scope.clientWidth, H = scope.clientHeight;
      glScope.clearRect(0,0,W,H);
      // grid + midline
      glScope.fillStyle = '#0b1020'; glScope.fillRect(0,0,W,H);
      glScope.strokeStyle = 'rgba(255,255,255,0.06)'; glScope.lineWidth = 1;
      glScope.beginPath(); glScope.moveTo(0, H/2); glScope.lineTo(W, H/2); glScope.stroke();
      for (let x=0; x<=W; x+=W/10){ glScope.beginPath(); glScope.moveTo(x,0); glScope.lineTo(x,H); glScope.stroke(); }
      // waveform
      glScope.lineWidth = 2.2; glScope.strokeStyle = '#22c55e'; glScope.beginPath();
      const step = data.length / W;
      for (let x=0; x<W; x++){
        const i = Math.floor(x * step);
        const v = data[i];                       // [-1..1]
        const y = H/2 - v * (H*0.45);
        x===0 ? glScope.moveTo(x,y) : glScope.lineTo(x,y);
      }
      glScope.stroke();
      drawRAF1 = requestAnimationFrame(drawScope);
    }

    // --- Drawing: pitch timeline (scrolling)
    const WINDOW_SECONDS = 20;           // fenêtre visible (défilement) – ajustable
    function drawPitchTimeline(){
      const W = pitchCanvas.clientWidth, H = pitchCanvas.clientHeight;
      glPitch.clearRect(0,0,W,H);
      // fond + grille
      glPitch.fillStyle = '#0b1020'; glPitch.fillRect(0,0,W,H);
      // ligne médiane (0 cents)
      glPitch.strokeStyle = 'rgba(255,255,255,0.15)'; glPitch.lineWidth = 1.5;
      glPitch.beginPath(); glPitch.moveTo(0,H/2); glPitch.lineTo(W,H/2); glPitch.stroke();
      // légères lignes guides (±200 cents)
      glPitch.strokeStyle = 'rgba(255,255,255,0.06)';
      [H*0.25, H*0.75].forEach(y=>{ glPitch.beginPath(); glPitch.moveTo(0,y); glPitch.lineTo(W,y); glPitch.stroke(); });

      if (pitchArray.length<2){ drawRAF2 = requestAnimationFrame(drawPitchTimeline); return; }

      // borne temporelle: on garde les N dernières secondes
      const now = performance.now()/1000;
      const tMin = now - WINDOW_SECONDS;

      // transformer en coords: x = temps (linéaire), y = cents (−300..+300 -> plein cadre)
      const centsRange = 600; // ±300 cents visibles (demi-ton au total = 200 cents; ici on laisse marge)
      const visible = pitchArray.filter(p => p.t >= tMin);
      if (visible.length<2){ drawRAF2 = requestAnimationFrame(drawPitchTimeline); return; }

      const t0 = visible[0].t;
      const t1 = visible[visible.length-1].t;
      const span = Math.max(1e-3, t1 - tMin); // étendue de la fenêtre

      // courbe
      glPitch.lineWidth = 2.2; glPitch.strokeStyle = '#60a5fa';
      glPitch.beginPath();
      let moved=false;
      for (const p of visible){
        const x = ((p.t - tMin) / span) * W;
        const y = H/2 - (p.cents / (centsRange/2)) * (H/2); // 0 cent milieu, + haut = aigu
        if (!isFinite(y)) continue;
        if (!moved){ glPitch.moveTo(x,y); moved=true; } else { glPitch.lineTo(x,y); }
      }
      glPitch.stroke();

      drawRAF2 = requestAnimationFrame(drawPitchTimeline);
    }

    // --- INITIALISER
    btnInit.addEventListener('click', async ()=>{
      addLog('[INFO] [Test] 🚀 Initialisation de l\'AudioEngine...');
      try{
        const opts={ sampleRate: CONFIG?.audio?.sampleRate ?? 48000, latencyHint:'interactive' };
        if (typeof AudioEngine.create === 'function') {
          audioEngine = await AudioEngine.create(opts);
        } else if (typeof AudioEngine.initialize === 'function') {
          audioEngine = await AudioEngine.initialize(opts);
        }
        if (!audioEngine) {
          audioEngine = (typeof AudioEngine.getInstance === 'function')
            ? AudioEngine.getInstance(opts)
            : new AudioEngine(opts);
        }
        const initFn =
          (typeof audioEngine.initialize === 'function' && 'initialize') ||
          (typeof audioEngine.init === 'function' && 'init') ||
          (typeof audioEngine.setup === 'function' && 'setup') ||
          (typeof audioEngine.start === 'function' && 'start') || null;
        if (initFn) await audioEngine[initFn]();

        const ctx = audioEngine.getContext?.() || audioEngine.context;
        if (!ctx) throw new Error('AudioContext introuvable');
        if (ctx.state!=='running' && typeof ctx.resume==='function') await ctx.resume();

        startContextTicker(ctx);
        sysStatus.innerHTML = '<span class="ok">Système initialisé avec succès</span><br>AudioEngine opérationnel. Vous pouvez maintenant tester le microphone.';
        btnMic.disabled=false; btnDestroy.disabled=false; btnRec.disabled=false;

      }catch(e){
        sysStatus.innerHTML = `<span class="err">Échec d\'initialisation</span><br>${e?.message??e}`;
        addLog(`[ERROR] [Test] Init AudioEngine: ${e?.message??e}`);
      }
    });

    // --- TEST MICRO + scopes + pitch
    btnMic.addEventListener('click', async ()=>{
      Logger.info('Test','🎤 Test du microphone...');
      try{
        if(!audioEngine){ addLog('[WARN] [Test] AudioEngine non initialisé.'); return; }
        if(!micManager){
          micManager = new MicrophoneManager(audioEngine);
          Logger.info('MicrophoneManager','MicrophoneManager créé');
        }
        const ok = await micManager.requestPermission();
        if(!ok){ addLog('[ERROR] [Test] Accès micro refusé ou erreur.'); return; }

        const stream = micManager.getStream();
        if(!stream){ addLog('[ERROR] [Test] Flux micro introuvable.'); return; }

        const source = micManager.createSource();
        if(!source){ addLog('[WARN] [Test] Flux ouvert, source WebAudio non créée.'); return; }

        const ctx = audioEngine.getContext?.();
        analyser = ctx.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);

        // (re)lancer dessins
        if (drawRAF1) cancelAnimationFrame(drawRAF1);
        if (drawRAF2) cancelAnimationFrame(drawRAF2);
        drawScope();
        drawPitchTimeline();

        // Boucle de détection pitch (~60 fps)
        const buf = new Float32Array(analyser.fftSize);
        const tickPitch = ()=>{
          if (!analyser) return;
          analyser.getFloatTimeDomainData(buf);
          const {freq, conf} = detectPitchYIN(buf, ctx.sampleRate);
          if (freq && conf>0.6){ // simple gate de confiance
            const data = freqToNoteData(freq);
            pitchInfo.textContent = `${data.note}${data.oct} • ${freq.toFixed(1)} Hz • ${data.cents>0?'+':''}${data.cents} cents`;
            // pousser point sur timeline (temps = now)
            pitchArray.push({ t: performance.now()/1000, cents: data.cents });
            // garder les derniers WINDOW_SECONDS
            const tMin = (performance.now()/1000) - WINDOW_SECONDS*2; // marge
            while (pitchArray.length && pitchArray[0].t < tMin) pitchArray.shift();
          } else {
            // pas de pitch fiable
          }
          requestAnimationFrame(tickPitch);
        };
        requestAnimationFrame(tickPitch);

        addLog('[INFO] [Test] Micro OK → scopes + pitch actifs.');
      }catch(e){
        Logger.error('Test','Erreur test micro',{ message:e?.message, name:e?.name });
        addLog(`[ERROR] [Test] ${e?.name??'Error'}: ${e?.message??e}`);
      }
    });

    // --- ENREGISTRER 5s (WebM/Opus)
    btnRec.addEventListener('click', async ()=>{
      try{
        if (!micManager || !micManager.isGranted()){
          Logger.warn('Test','Micro non prêt — clique d’abord sur "Tester Microphone".'); return;
        }
        const stream = micManager.getStream(); if (!stream){ Logger.error('Test','Pas de stream micro.'); return; }
        const chunks=[];
        const mt = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
        mediaRecorder = new MediaRecorder(stream, { mimeType: mt });
        mediaRecorder.ondataavailable = e => { if (e.data?.size) chunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: mt });
          const url = URL.createObjectURL(blob);
          const audio=document.createElement('audio'); audio.controls=true; audio.src=url;
          const a=document.createElement('a'); a.href=url; a.download=`enregistrement-${Date.now()}.webm`; a.textContent='Télécharger (webm)';
          logBox.appendChild(document.createTextNode('\n[INFO] [Test] Enregistrement terminé (5s)'));
          logBox.appendChild(document.createElement('br'));
          logBox.appendChild(audio);
          logBox.appendChild(document.createElement('br'));
          logBox.appendChild(a);
          logBox.appendChild(document.createElement('br'));
        };
        Logger.info('Test','Enregistrement démarré (5s)…');
        mediaRecorder.start();
        setTimeout(()=>{ if (mediaRecorder?.state==='recording'){ mediaRecorder.stop(); Logger.info('Test','Enregistrement arrêté.'); } }, 5000);
      }catch(e){
        Logger.error('Test','Erreur MediaRecorder',{ name:e?.name, message:e?.message });
        addLog(`[ERROR] [Test] MediaRecorder: ${e?.message??e}`);
      }
    });

    // --- DÉTRUIRE
    btnDestroy.addEventListener('click', async ()=>{
      try{
        if (drawRAF1) cancelAnimationFrame(drawRAF1);
        if (drawRAF2) cancelAnimationFrame(drawRAF2);
        analyser?.disconnect(); analyser=null;
        if(mediaRecorder?.state==='recording'){ try{ mediaRecorder.stop(); }catch{} }
        micManager?.destroy?.(); micManager=null;
        if(audioEngine){
          const ctx = audioEngine.getContext?.() || audioEngine.context;
          if (ctx?.state==='running' && typeof ctx.close==='function'){ await ctx.close(); }
          audioEngine=null;
        }
        stopContextTicker();
        pitchArray.length = 0;
        glScope.clearRect(0,0,scope.clientWidth,scope.clientHeight);
        glPitch.clearRect(0,0,pitchCanvas.clientWidth,pitchCanvas.clientHeight);
        pitchInfo.textContent='—';
        sysStatus.innerHTML='Réinitialisé. Cliquez sur “Initialiser” pour recommencer.';
        btnMic.disabled=true; btnDestroy.disabled=true; btnRec.disabled=true;
        ctxState.textContent = ctxRate.textContent = ctxLatency.textContent = ctxTime.textContent = '—';
        addLog('[INFO] [Test] Système détruit.');
      }catch(e){ addLog(`[ERROR] [Test] Destroy: ${e?.message??e}`); }
    });

    btnClear.addEventListener('click',()=>{ logBox.textContent='Système de logs prêt…'; });
  </script>
</body>
</html>
