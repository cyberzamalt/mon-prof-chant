<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Test Audio Core ‚Ä¢ Pitch absolu (timeline)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--bg:#f7f7fb;--card:#fff;--text:#1f2937;--muted:#6b7280;--ok:#16a34a;--warn:#d97706;--err:#dc2626;--blue:#4f46e5;}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1000px;margin:24px auto;padding:16px}
    .title{font-size:24px;font-weight:800;margin:8px 0 4px}
    .subtitle{color:var(--muted);margin:0 0 16px}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 2px 8px rgba(0,0,0,.06);margin:12px 0}
    .row{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .kv{border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .kv b{display:block;color:var(--muted);font-weight:600;margin-bottom:6px}
    .badge{display:inline-flex;align-items:center;gap:8px;background:#e8f6ef;color:var(--ok);border:1px solid #b7e4c7;padding:8px 12px;border-radius:10px;font-weight:600}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
    .b1{background:#e5e7eb;color:#111827}
    .b2{background:#111827;color:#fff}
    .b3{background:#e11d48;color:#fff}
    .b4{background:#10b981;color:#fff}
    .b1[disabled],.b2[disabled],.b3[disabled]{opacity:.45;cursor:not-allowed}
    pre{background:#0b1020;color:#dbeafe;border-radius:10px;padding:12px;max-height:280px;overflow:auto}

    .pill{display:inline-block;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;padding:6px 10px;border-radius:999px;font-weight:700}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .seg{display:inline-flex;overflow:hidden;border-radius:10px;border:1px solid #e5e7eb}
    .seg button{background:#f3f4f6;color:#111827;border:0;padding:8px 10px}
    .seg button.active{background:#111827;color:#fff}

    /* Timeline conteneur + canvases */
    .timeline-wrap{overflow-x:auto; overflow-y:hidden; border:1px solid #e5e7eb; border-radius:10px; background:#0b1020}
    .tl-layer{display:block}
    #pitchCanvas{height:260px; display:block}
    #axisCanvas{height:32px; display:block; background:#0b1020}
    .axis-label{color:#9ca3af; font-size:12px; margin-top:6px}

    /* Curseur temps */
    .cursor{position:absolute; top:0; bottom:0; width:2px; background:#f59e0b; pointer-events:none}

    /* Container relatif pour curseur */
    .relative{position:relative}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">üé§ Test Audio Core</div>
    <p class="subtitle">Visualisation **Pitch absolu** (notes) avec timeline fixe, ligne m√©diane et r√®gle de temps</p>

    <div class="card">
      <div class="badge">üîí Protocole d√©tect√© : <span id="protoTxt" style="margin-left:6px">‚Äî</span></div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:6px">‚úÖ Statut du Syst√®me</div>
      <div id="sysStatus" class="muted">En attente‚Ä¶ cliquez sur ‚ÄúInitialiser‚Äù.</div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">üéõÔ∏è AudioContext</div>
      <div class="row">
        <div class="kv"><b>√âTAT</b><span id="ctxState">‚Äî</span></div>
        <div class="kv"><b>SAMPLE RATE</b><span id="ctxRate">‚Äî</span></div>
        <div class="kv"><b>BASE LATENCY</b><span id="ctxLatency">‚Äî</span></div>
        <div class="kv"><b>CURRENT TIME</b><span id="ctxTime">‚Äî</span></div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">üß≠ Navigateur</div>
      <div class="row">
        <div class="kv"><b>NAVIGATEUR</b><span id="navName">‚Äî</span></div>
        <div class="kv"><b>VERSION</b><span id="navVer">‚Äî</span></div>
        <div class="kv"><b>OS</b><span id="navOS">‚Äî</span></div>
        <div class="kv"><b>MOBILE</b><span id="navMob">‚Äî</span></div>
      </div>
    </div>

    <div class="btns">
      <button class="b4" id="btnInit">‚úÖ Initialiser</button>
      <button class="b2" id="btnMic" disabled>üé§ Tester Microphone</button>
      <button class="b2" id="btnRec" disabled>üéôÔ∏è Enregistrer 5s</button>
      <button class="b3" id="btnDestroy" disabled>üß® D√©truire</button>
      <button class="b1" id="btnClear">üßπ Effacer Logs</button>
    </div>

    <div class="card">
      <div style="font-weight:800;margin-bottom:10px">Console</div>
      <pre id="logBox">Syst√®me de logs pr√™t‚Ä¶</pre>
    </div>

    <div class="card">
      <div class="toolbar" style="justify-content:space-between;margin-bottom:8px">
        <div class="toolbar" style="gap:12px">
          <div><b>Pitch</b> (ligne m√©diane = note de r√©f√©rence)</div>
          <div class="seg" id="modeSeg">
            <button data-mode="abs" class="active">Absolu (notes)</button>
            <button data-mode="cents">Cents (justesse)</button>
          </div>
          <div class="seg" id="zoomSeg" title="Zoom vertical">
            <button data-zoom="1" class="active">x1</button>
            <button data-zoom="2">x2</button>
            <button data-zoom="4">x4</button>
          </div>
          <span class="pill" id="pitchInfo">‚Äî</span>
        </div>
        <div class="pill" id="refInfo">R√©f√©rence: ‚Äî</div>
      </div>

      <div class="relative">
        <div class="timeline-wrap" id="timeline">
          <canvas id="pitchCanvas" class="tl-layer" width="1200"></canvas>
          <canvas id="axisCanvas"  class="tl-layer" width="1200"></canvas>
        </div>
        <div id="cursor" class="cursor" style="left:0; display:none"></div>
      </div>

      <div class="axis-label">√âchelle temps (s)</div>
    </div>
  </div>

  <script type="module">
    import AudioEngine from './src/audio/core/AudioEngine.js';
    import { Logger } from './src/logging/Logger.js';
    import MicrophoneManager from './src/audio/core/MicrophoneManager.js';
    import BrowserDetector from './src/utils/BrowserDetector.js';
    import './src/audio/core/ErrorHandler.js';
    import { CONFIG } from './src/config.js';

    // UI refs
    const logBox=document.getElementById('logBox');
    const btnInit=document.getElementById('btnInit');
    const btnMic=document.getElementById('btnMic');
    const btnRec=document.getElementById('btnRec');
    const btnDestroy=document.getElementById('btnDestroy');
    const btnClear=document.getElementById('btnClear');
    const protoTxt=document.getElementById('protoTxt');
    const sysStatus=document.getElementById('sysStatus');
    const ctxState=document.getElementById('ctxState');
    const ctxRate=document.getElementById('ctxRate');
    const ctxLatency=document.getElementById('ctxLatency');
    const ctxTime=document.getElementById('ctxTime');
    const navName=document.getElementById('navName');
    const navVer=document.getElementById('navVer');
    const navOS=document.getElementById('navOS');
    const navMob=document.getElementById('navMob');

    const timeline=document.getElementById('timeline');
    const pitchCanvas=document.getElementById('pitchCanvas');
    const axisCanvas=document.getElementById('axisCanvas');
    const gPitch=pitchCanvas.getContext('2d');
    const gAxis=axisCanvas.getContext('2d');

    const modeSeg=document.getElementById('modeSeg');
    const zoomSeg=document.getElementById('zoomSeg');
    const pitchInfo=document.getElementById('pitchInfo');
    const refInfo=document.getElementById('refInfo');
    const cursor=document.getElementById('cursor');

    function addLog(line){ const now=new Date().toTimeString().slice(0,8); logBox.textContent+=`\n[${now}] ${line}`; logBox.scrollTop=logBox.scrollHeight; }
    Logger.setExternalSink?.((level,scope,msg,data)=>{ const d=data?` | ${JSON.stringify(data)}`:''; addLog(`[${level}] [${scope}] ${msg}${d}`); });

    // State
    let audioEngine=null, micManager=null, analyser=null, mediaRecorder=null, ctxTicker=null;
    let mode='abs';           // 'abs' | 'cents'
    let zoom=1;               // 1 | 2 | 4 (vertical zoom)
    let refMidi=null;         // note de r√©f√©rence (midi)
    let startT=null;          // t0 de la prise (performance.now()/1000)
    let lastDrawDuration=0;   // dur√©e d√©j√† allou√©e sur canvas
    const A4=440, NOTE=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const PX_PER_SEC=100;     // densit√© horizontale : 100 px / seconde
    const PX_PER_SEMITONE=20; // densit√© verticale pour "abs" √† zoom 1
    const MAX_MINUTES=15;     // garde-fou
    const points=[];          // {t:seconds, midi, freq, cents, conf}

    // DPR helpers
    const dpr=window.devicePixelRatio||1;
    function setCanvasSize(canvas, cssW, cssH){
      canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
      canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr);
      const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    // Boot
    (function(){
      const https = location.protocol==='https:' || location.hostname==='localhost';
      protoTxt.textContent = https ? 'HTTPS (s√©curis√©)' : 'HTTP (non s√©curis√©)';
      protoTxt.style.color = https ? 'var(--ok)' : 'var(--err)';
      const b=BrowserDetector.detect();
      navName.textContent=b?.name??'‚Äî'; navVer.textContent=b?.fullVersion??(b?.version??'‚Äî'); navOS.textContent=b?.os??'‚Äî'; navMob.textContent=b?.mobile?'Oui':'Non';
      Logger.info('Test','üì± Page charg√©e');
      Logger.info('Protocol', https ? 'HTTPS d√©tect√© - Microphone accessible' : 'HTTP d√©tect√© - Activer HTTPS pour le micro');
      Logger.info('BrowserDetector','D√©tection du navigateur...');
      Logger.info('BrowserDetector',`${b?.name??'?'} ${b?.fullVersion??b?.version??''} sur ${b?.os??'?'}`, b);
    })();

    // Mode / Zoom UI
    modeSeg.addEventListener('click', (e)=>{
      const btn=e.target.closest('button'); if(!btn) return;
      mode=btn.dataset.mode; for(const b of modeSeg.querySelectorAll('button')) b.classList.toggle('active', b===btn);
      redrawAll();
    });
    zoomSeg.addEventListener('click', (e)=>{
      const btn=e.target.closest('button'); if(!btn) return;
      zoom=Number(btn.dataset.zoom); for(const b of zoomSeg.querySelectorAll('button')) b.classList.toggle('active', b===btn);
      redrawAll();
    });

    // Context ticker
    function startCtxTicker(ctx){
      stopCtxTicker();
      ctxTicker=setInterval(()=>{ try{
        ctxState.textContent=ctx?.state??'‚Äî';
        ctxRate.textContent=`${ctx?.sampleRate??0} Hz`;
        const base=typeof ctx?.baseLatency==='number'?ctx.baseLatency:0;
        ctxLatency.textContent=`${(base*1000).toFixed(2)} ms`;
        ctxTime.textContent=`${(ctx?.currentTime??0).toFixed(2)} s`;
      }catch{} },250);
    }
    function stopCtxTicker(){ if(ctxTicker){ clearInterval(ctxTicker); ctxTicker=null; } }

    // Maths
    function midiFromFreq(freq){ return 69 + 12*Math.log2(freq/A4); }
    function noteLabelFromMidi(m){
      const i=((Math.round(m)%12)+12)%12; const o=Math.floor(Math.round(m)/12)-1;
      return `${NOTE[i]}${o}`;
    }
    function centsFromMidi(m){
      const nearest=Math.round(m);
      return Math.round((m-nearest)*100);
    }

    // Layout / Drawing
    function ensureCanvasDuration(seconds){
      const maxSec = Math.min(seconds, MAX_MINUTES*60);
      const needW = Math.max(1200, Math.ceil(maxSec*PX_PER_SEC));
      // Si largeur n√©cessaire > largeur actuelle, on r√©-alloue (et on re-dessine)
      const cssW = needW;
      setCanvasSize(pitchCanvas, cssW, 260);
      setCanvasSize(axisCanvas,  cssW, 32);
      lastDrawDuration=maxSec;
    }

    function yFromMidi(m){
      // m relative to ref: Œîsemitones (positif = aigu)
      const dy=(m - (refMidi??m)); // si pas ref, 0 ‚Üí centr√©
      const H=260;
      const pixelsPerSemi = PX_PER_SEMITONE*zoom;
      const y = H/2 - dy*pixelsPerSemi;
      return y;
    }
    function yFromCents(c){
      const H=260;
      // ¬±300 cents visibles env (ajust√© par zoom)
      const C_RANGE = 300/zoom; // plus de d√©tails en zoom
      const y = H/2 - (c / C_RANGE) * (H/2);
      return y;
    }

    function drawAxis(durationSec){
      const W=pitchCanvas.clientWidth, H=axisCanvas.clientHeight;
      gAxis.clearRect(0,0,W,H);
      gAxis.fillStyle='#0b1020'; gAxis.fillRect(0,0,W,H);
      gAxis.strokeStyle='rgba(255,255,255,.25)'; gAxis.lineWidth=1;

      // graduations chaque 1s, labels toutes les 5s
      const totalSec = Math.ceil(durationSec);
      for(let s=0; s<=totalSec; s++){
        const x = s*PX_PER_SEC+0.5;
        gAxis.beginPath(); gAxis.moveTo(x, 0); gAxis.lineTo(x, s%5===0?H: H*0.5); gAxis.stroke();
        if (s%5===0){
          const mm = Math.floor(s/60), ss=(s%60).toString().padStart(2,'0');
          gAxis.fillStyle='#9ca3af';
          gAxis.font='12px system-ui';
          gAxis.fillText(`${mm}:${ss}`, x+4, H-6);
        }
      }
    }

    function drawPitch(durationSec){
      const W=pitchCanvas.clientWidth, H=pitchCanvas.clientHeight;
      gPitch.clearRect(0,0,W,H);
      // fond
      gPitch.fillStyle='#0b1020'; gPitch.fillRect(0,0,W,H);

      // Grille horizontale (semitones ou rep√®res cents)
      gPitch.strokeStyle='rgba(255,255,255,.08)';
      gPitch.lineWidth=1;
      if (mode==='abs'){
        // Lignes chaque demi-ton par rapport √† la ref
        const pixelsPerSemi = PX_PER_SEMITONE*zoom;
        if (!refMidi){ // pas encore de ref ‚Üí juste m√©diane
          gPitch.beginPath(); gPitch.moveTo(0,H/2); gPitch.lineTo(W,H/2); gPitch.stroke();
        } else {
          // monte/descend jusqu'√† limites visibles
          for(let k=-50;k<=50;k++){ // borne large
            const y = H/2 - k*pixelsPerSemi;
            if (y<0||y>H) continue;
            gPitch.strokeStyle = (k%2===0) ? 'rgba(255,255,255,.12)' : 'rgba(255,255,255,.06)';
            gPitch.beginPath(); gPitch.moveTo(0,y); gPitch.lineTo(W,y); gPitch.stroke();
          }
        }
      } else {
        // Cents: m√©diane 0, rep√®res ¬±100, ¬±200
        const bands=[0,100,200,-100,-200];
        for (const c of bands){
          const y=yFromCents(c);
          gPitch.strokeStyle = c===0 ? 'rgba(255,255,255,.25)' : 'rgba(255,255,255,.08)';
          gPitch.beginPath(); gPitch.moveTo(0,y); gPitch.lineTo(W,y); gPitch.stroke();
        }
      }

      // Courbe
      if (points.length<2) return;
      gPitch.lineWidth=2.2; gPitch.strokeStyle='#60a5fa'; gPitch.beginPath();
      let moved=false;
      for (const p of points){
        const x=p.t*PX_PER_SEC + 0.5;
        let y;
        if (mode==='abs'){
          if (!refMidi) continue; // on attend la ref
          if (!isFinite(p.midi)) { moved=false; continue; }
          y = yFromMidi(p.midi);
        } else {
          if (!Number.isFinite(p.cents)) { moved=false; continue; }
          y = yFromCents(p.cents);
        }
        if (!moved){ gPitch.moveTo(x,y); moved=true; } else { gPitch.lineTo(x,y); }
      }
      gPitch.stroke();

      // ligne m√©diane
      gPitch.strokeStyle='rgba(255,255,255,.25)'; gPitch.lineWidth=1.5;
      gPitch.beginPath(); gPitch.moveTo(0,H/2); gPitch.lineTo(W,H/2); gPitch.stroke();

      // curseur
      if (startT!=null){
        const now=performance.now()/1000;
        const x=(now-startT)*PX_PER_SEC;
        cursor.style.display='block';
        cursor.style.left = (x - timeline.scrollLeft) + 'px';
      }
    }

    function redrawAll(){
      const duration = points.length? points[points.length-1].t : 0;
      ensureCanvasDuration(duration+1);
      drawAxis(duration);
      drawPitch(duration);
    }

    // INITIALISER
    btnInit.addEventListener('click', async ()=>{
      addLog('[INFO] [Test] üöÄ Initialisation de l\'AudioEngine...');
      try{
        const opts={ sampleRate: CONFIG?.audio?.sampleRate ?? 48000, latencyHint:'interactive' };
        if (typeof AudioEngine.create==='function') audioEngine=await AudioEngine.create(opts);
        else if (typeof AudioEngine.initialize==='function') audioEngine=await AudioEngine.initialize(opts);
        if(!audioEngine) audioEngine=(typeof AudioEngine.getInstance==='function')?AudioEngine.getInstance(opts):new AudioEngine(opts);
        const initFn=(audioEngine.initialize&&'initialize')||(audioEngine.init&&'init')||(audioEngine.setup&&'setup')||(audioEngine.start&&'start')||null;
        if(initFn) await audioEngine[initFn]();

        const ctx=audioEngine.getContext?.()||audioEngine.context;
        if(!ctx) throw new Error('AudioContext introuvable');
        if(ctx.state!=='running' && ctx.resume) await ctx.resume();

        startCtxTicker(ctx);
        btnMic.disabled=false; btnDestroy.disabled=false; btnRec.disabled=false;
        sysStatus.innerHTML='<span style="color:var(--ok)">Syst√®me initialis√© avec succ√®s</span><br>AudioEngine op√©rationnel. Vous pouvez maintenant tester le microphone.';

        // taille initiale
        ensureCanvasDuration(12); // 12s visibles au d√©part
        drawAxis(12); drawPitch(0);
      }catch(e){
        sysStatus.innerHTML=`<span style="color:var(--err)">√âchec d'initialisation</span><br>${e?.message??e}`;
        addLog(`[ERROR] [Test] Init AudioEngine: ${e?.message??e}`);
      }
    });

    // TEST MICRO + enregistrement des points
    btnMic.addEventListener('click', async ()=>{
      Logger.info('Test','üé§ Test du microphone...');
      try{
        if(!audioEngine){ addLog('[WARN] [Test] AudioEngine non initialis√©.'); return; }
        if(!micManager){ micManager=new MicrophoneManager(audioEngine); }
        const ok=await micManager.requestPermission(); if(!ok){ addLog('[ERROR] [Test] Acc√®s micro refus√©.'); return; }
        const src=micManager.createSource(); if(!src){ addLog('[WARN] [Test] Source WebAudio non cr√©√©e.'); return; }

        const ctx=audioEngine.getContext?.();
        analyser = ctx.createAnalyser(); analyser.fftSize=2048; src.connect(analyser);

        // reset prise
        points.length=0; refMidi=null; startT=performance.now()/1000; refInfo.textContent='R√©f√©rence: ‚Äî';
        redrawAll();

        // boucle pitch
        const buf=new Float32Array(analyser.fftSize);
        const loop=()=>{
          if(!analyser){ requestAnimationFrame(loop); return; }
          analyser.getFloatTimeDomainData(buf);
          const {freq, conf}=detectPitch(buf, ctx.sampleRate);
          const now=performance.now()/1000;
          const t=now-startT;

          if(freq && conf>0.6){
            const midi=midiFromFreq(freq);
            const cents=centsFromMidi(midi);

            // r√©f√©rence = premi√®re note stable
            if(refMidi==null) { refMidi=Math.round(midi); refInfo.textContent=`R√©f√©rence: ${noteLabelFromMidi(refMidi)}`; }

            pitchInfo.textContent=`${noteLabelFromMidi(Math.round(midi))} ‚Ä¢ ${freq.toFixed(1)} Hz ‚Ä¢ ${cents>0?'+':''}${cents} cents`;
            points.push({t, midi, freq, cents, conf});
          }else{
            // silence : trou (garde la timeline)
            points.push({t, midi:NaN, freq:NaN, cents:NaN, conf:0});
          }

          // augmenter largeur si besoin & dessiner incr√©mentalement
          const duration = t;
          if (duration > lastDrawDuration-1){
            ensureCanvasDuration(duration+3);
          }
          drawAxis(duration);
          drawPitch(duration);

          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);

        addLog('[INFO] [Test] Micro OK ‚Üí pitch absolu actif (timeline fixe).');
        // auto-scroll pendant la prise
        const autoScroll=()=>{
          if(startT==null) return;
          const now=performance.now()/1000;
          const x=(now-startT)*PX_PER_SEC;
          const margin=100;
          if (x > timeline.scrollLeft + timeline.clientWidth - margin){
            timeline.scrollLeft = x - timeline.clientWidth + margin;
          }
          requestAnimationFrame(autoScroll);
        };
        requestAnimationFrame(autoScroll);
      }catch(e){
        Logger.error('Test','Erreur test micro',{message:e?.message,name:e?.name});
        addLog(`[ERROR] [Test] ${e?.name??'Error'}: ${e?.message??e}`);
      }
    });

    // ENREGISTRER 5s (WebM/Opus)
    btnRec.addEventListener('click', async ()=>{
      try{
        if(!micManager || !micManager.isGranted()){ addLog('[WARN] [Test] Micro non pr√™t.'); return; }
        const stream=micManager.getStream(); if(!stream){ addLog('[ERROR] [Test] Pas de stream.'); return; }
        const chunks=[];
        const mt=MediaRecorder.isTypeSupported('audio/webm;codecs=opus')?'audio/webm;codecs=opus':'audio/webm';
        mediaRecorder=new MediaRecorder(stream,{mimeType:mt});
        mediaRecorder.ondataavailable=e=>{ if(e.data?.size) chunks.push(e.data); };
        mediaRecorder.onstop=()=>{
          const blob=new Blob(chunks,{type:mt}); const url=URL.createObjectURL(blob);
          const audio=document.createElement('audio'); audio.controls=true; audio.src=url;
          const a=document.createElement('a'); a.href=url; a.download=`enregistrement-${Date.now()}.webm`; a.textContent='T√©l√©charger (webm)';
          logBox.appendChild(document.createTextNode('\n[INFO] [Test] Enregistrement termin√© (5s)'));
          logBox.appendChild(document.createElement('br')); logBox.appendChild(audio);
          logBox.appendChild(document.createElement('br')); logBox.appendChild(a);
          logBox.appendChild(document.createElement('br'));
        };
        Logger.info('Test','Enregistrement d√©marr√© (5s)‚Ä¶'); mediaRecorder.start();
        setTimeout(()=>{ if(mediaRecorder?.state==='recording'){ mediaRecorder.stop(); Logger.info('Test','Enregistrement arr√™t√©.'); } },5000);
      }catch(e){
        Logger.error('Test','Erreur MediaRecorder',{name:e?.name,message:e?.message});
        addLog(`[ERROR] [Test] MediaRecorder: ${e?.message??e}`);
      }
    });

    // D√âTRUIRE
    btnDestroy.addEventListener('click', async ()=>{
      try{
        analyser?.disconnect(); analyser=null;
        if(mediaRecorder?.state==='recording'){ try{ mediaRecorder.stop(); }catch{} }
        micManager?.destroy?.(); micManager=null;
        if(audioEngine){
          const ctx=audioEngine.getContext?.()||audioEngine.context;
          if(ctx?.state==='running' && ctx.close) await ctx.close();
          audioEngine=null;
        }
        stopCtxTicker();
        points.length=0; refMidi=null; startT=null; lastDrawDuration=0;
        setCanvasSize(pitchCanvas, 1200, 260); setCanvasSize(axisCanvas, 1200, 32);
        drawAxis(12); drawPitch(0);
        cursor.style.display='none';
        pitchInfo.textContent='‚Äî'; refInfo.textContent='R√©f√©rence: ‚Äî';
        btnMic.disabled=true; btnDestroy.disabled=true; btnRec.disabled=true;
        ctxState.textContent=ctxRate.textContent=ctxLatency.textContent=ctxTime.textContent='‚Äî';
        sysStatus.innerHTML='R√©initialis√©. Cliquez sur ‚ÄúInitialiser‚Äù pour recommencer.';
        addLog('[INFO] [Test] Syst√®me d√©truit.');
      }catch(e){ addLog(`[ERROR] [Test] Destroy: ${e?.message??e}`); }
    });

    btnClear.addEventListener('click', ()=>{ logBox.textContent='Syst√®me de logs pr√™t‚Ä¶'; });

    // --- Pitch detection (YIN simplifi√©) ---
    function detectPitch(buf, sr){
      const N=buf.length;
      const tauMax=Math.min(Math.floor(sr/50), N-1);
      const tauMin=Math.max(2, Math.floor(sr/1000));
      const diff=new Float32Array(tauMax+1);
      for(let tau=tauMin;tau<=tauMax;tau++){
        let s=0; for(let i=0;i<N-tau;i++){ const d=buf[i]-buf[i+tau]; s+=d*d; }
        diff[tau]=s;
      }
      const cmnd=new Float32Array(tauMax+1); let run=0;
      for(let tau=tauMin;tau<=tauMax;tau++){ run+=diff[tau]; cmnd[tau]=diff[tau]*tau/(run||1); }
      const th=0.12; let tau=tauMin;
      for(;tau<=tauMax;tau++){ if(cmnd[tau]<th){ while(tau+1<=tauMax && cmnd[tau+1]<cmnd[tau]) tau++; break; } }
      if(tau>tauMax) return {freq:null,conf:0};
      const x0=(tau<=1)?tau:tau-1, x2=(tau+1<=tauMax)?tau+1:tau;
      const y0=cmnd[x0], y1=cmnd[tau], y2=cmnd[x2], den=(y0+y2-2*y1);
      const better=tau + (den ? ( (y0-y2)/(2*den) ) : 0);
      return {freq: sr/better, conf: 1-y1};
    }
  </script>
</body>
</html>
