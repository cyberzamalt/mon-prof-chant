<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Test Audio Core ‚Äî DEBUG VERSION (Logs Pr√©cis)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root {
  --bg: #0b1220;
  --panel: #0e1729;
  --card: #111a2e;
  --grid: #1a2642;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --ok: #10b981;
  --err: #ef4444;
  --blue: #3b82f6;
  --green: #22c55e;
  --orange: #f59e0b;
  --debug: #ff00ff;
}

* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; }
body {
  background: var(--bg);
  color: var(--text);
  font: 13px/1.45 monospace;
  padding: 0;
}

.wrap {
  max-width: 1400px;
  margin: 20px auto;
  padding: 0 16px;
}

.h1 {
  font-weight: 800;
  font-size: 18px;
  margin: 0 0 16px 0;
  color: var(--debug);
}

.h2 {
  font-weight: 700;
  font-size: 13px;
  margin: 0 0 8px 0;
}

.bar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  margin-bottom: 12px;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 1px solid #1f2a44;
  background: var(--card);
  color: var(--text);
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 12px;
  transition: all 0.2s;
  font-family: monospace;
}

.btn:hover:not([disabled]) {
  background: #16213a;
  border-color: #2a3a54;
}

.btn[disabled] {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn.ok {
  background: #0e1f14;
  border-color: #173621;
  color: #c8facc;
}

.btn.err {
  background: #2a0f14;
  border-color: #4a171f;
  color: #fecaca;
}

.timer {
  padding: 8px 12px;
  border: 1px solid #22304f;
  border-radius: 8px;
  background: var(--card);
  min-width: 60px;
  text-align: center;
  font-weight: 600;
  font-family: monospace;
}

.cols {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 16px;
}

@media (max-width: 1024px) {
  .cols {
    grid-template-columns: 1fr;
  }
}

.panel {
  background: var(--panel);
  border: 1px solid #1f2a44;
  border-radius: 12px;
  padding: 16px;
}

.canvasWrap {
  border: 2px solid var(--debug);
  border-radius: 8px;
  padding: 4px;
  background: #0b1324;
  margin: 8px 0;
  position: relative;
}

canvas {
  display: block;
  width: 100%;
  height: auto;
  background: #0b1324;
}

.log {
  background: #0b1020;
  border: 1px solid #1f2a44;
  border-radius: 8px;
  padding: 12px;
  color: #dbeafe;
  font-family: ui-monospace, monospace;
  font-size: 11px;
  max-height: 300px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
  line-height: 1.3;
}

.badge {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  border: 1px solid #22304f;
  background: #0b1220;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 11px;
  font-family: monospace;
}

.hint {
  color: var(--muted);
  font-size: 11px;
  margin: 6px 0 8px 0;
}

.debugInfo {
  background: #0b1020;
  border: 1px solid #22304f;
  border-radius: 6px;
  padding: 8px 10px;
  font-size: 11px;
  color: #cbd5e1;
  margin-top: 8px;
  font-family: monospace;
}

.right {
  margin-left: auto;
}

input[type="file"] {
  padding: 8px 12px;
  border: 1px solid #22304f;
  border-radius: 8px;
  background: #0f172a;
  color: var(--text);
  font-size: 12px;
}

.metrics {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 8px;
  font-size: 11px;
}

.metric {
  background: #0b1220;
  border: 1px solid #22304f;
  border-radius: 6px;
  padding: 6px 10px;
  font-family: monospace;
}

.controls {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.seg {
  display: inline-flex;
  border: 1px solid #22304f;
  background: var(--card);
  border-radius: 8px;
  overflow: hidden;
}

.seg button {
  padding: 8px 12px;
  border: 0;
  background: transparent;
  color: var(--text);
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  font-family: monospace;
}

.seg button.active {
  background: #16213a;
  color: #22c55e;
}
</style>
</head>
<body>

<!-- TONE.JS CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<!-- YIN DETECTOR -->
<script src="./src/vendor/yin-detector.js"></script>

<!-- PITCH SMOOTHER -->
<script src="./src/utils/pitch-smoothing.js"></script>

<div class="wrap">
  <div class="h1">üîß DEBUG: Test Audio Core ‚Äî Logs Pr√©cis Rendu Courbe</div>

  <div class="bar">
    <button id="btnMic" class="btn">üé§ Activer micro</button>

    <div class="seg">
      <button id="btnRecStart" class="btn">‚ñ∂ Enregistrer</button>
      <button id="btnRecStop" class="btn err" disabled>‚èπ Stop</button>
    </div>

    <div class="timer" id="timerRec">00:00</div>

    <span class="right badge" id="pitchyStatus">üîß DEBUG MODE</span>
  </div>

  <div class="cols">
    <div class="panel">
      <p class="h2">üìä CANVAS: Ta Prise (Debug)</p>
      <div class="hint">üé§ Courbe bleue = ton pitch liss√© | üü¢ Ligne verte = 0 cent (440 Hz)</div>
      <div class="canvasWrap">
        <canvas id="canvasRec" width="600" height="320"></canvas>
      </div>
      <div class="debugInfo" id="debugRec">Brutes: 0 | Liss√©s: 0 | Pts canvas: 0</div>
      <div class="controls">
        <button id="btnClearRec" class="btn">üóëÔ∏è Effacer</button>
      </div>
    </div>

    <div class="panel">
      <p class="h2">üìã LOGS DE RENDU</p>
      <div class="log" id="debugLog">Logs DEBUG activ√©s...</div>
    </div>
  </div>

  <div class="h1">üìã Logs Principaux</div>
  <div id="logBox" class="log">D√©marrage...</div>
</div>

<script src="./src/vendor/pitchy-lite.js"></script>
<script src="./src/utils/wav-export.js"></script>
<script src="./src/utils/mp3-export.js"></script>

<script>
/* ==================== LOGGER PRINCIPAL ==================== */
const logBox = document.getElementById('logBox');
const debugLog = document.getElementById('debugLog');

const log = (level, msg) => {
  const now = new Date();
  const h = String(now.getHours()).padStart(2, '0');
  const m = String(now.getMinutes()).padStart(2, '0');
  const s = String(now.getSeconds()).padStart(2, '0');
  const line = `[${h}:${m}:${s}] [${level}] ${msg}`;
  logBox.textContent += line + '\n';
  logBox.scrollTop = logBox.scrollHeight;
};

const debugLog_ = (msg) => {
  debugLog.textContent += msg + '\n';
  debugLog.scrollTop = debugLog.scrollHeight;
};

/* ==================== STATE ==================== */
let audioCtx = null;
let analyser = null;
let micStream = null;
let mediaRecorder = null;
let chunks = [];
let lastBlob = null;
let detector = null;
let smoother = null;
let recordedPitch = [];
let recordDetectionCount = 0;
let recordDetectionRawCount = 0;
let recStart = 0;
let timerInterval = null;
let rafId = null;

let drawCallCount = 0;
let tickCallCount = 0;
let pointsAddedTotal = 0;

const canvasRec = document.getElementById('canvasRec');
const ctxRec = canvasRec.getContext('2d');

const btnMic = document.getElementById('btnMic');
const btnRecStart = document.getElementById('btnRecStart');
const btnRecStop = document.getElementById('btnRecStop');
const timerRec = document.getElementById('timerRec');
const debugRec = document.getElementById('debugRec');
const btnClearRec = document.getElementById('btnClearRec');

/* ==================== CANVAS HELPERS ==================== */
function drawCanvasRec() {
  drawCallCount++;
  debugLog_(`[DRAW #${drawCallCount}] drawCanvasRec() appel√©e`);

  try {
    const w = canvasRec.width;
    const h = canvasRec.height;
    
    debugLog_(`  ‚Üí Canvas: ${w}x${h}`);
    
    // Fond
    ctxRec.fillStyle = '#0b1324';
    ctxRec.fillRect(0, 0, w, h);
    debugLog_(`  ‚Üí Fond rempli`);

    // Grille horizontale fine
    ctxRec.strokeStyle = '#1a2642';
    ctxRec.lineWidth = 0.5;
    for (let i = 0; i < 5; i++) {
      const y = (h / 4) * i;
      ctxRec.beginPath();
      ctxRec.moveTo(0, y);
      ctxRec.lineTo(w, y);
      ctxRec.stroke();
    }
    debugLog_(`  ‚Üí Grille trac√©e`);

    // Ligne de r√©f√©rence (0 cents) - verte en tirets
    ctxRec.strokeStyle = '#10b981';
    ctxRec.lineWidth = 2;
    ctxRec.setLineDash([4, 4]);
    ctxRec.beginPath();
    ctxRec.moveTo(0, h / 2);
    ctxRec.lineTo(w, h / 2);
    ctxRec.stroke();
    ctxRec.setLineDash([]);
    debugLog_(`  ‚Üí Ligne verte pointill√©e trac√©e (y=${h/2})`);

    // Labels Y
    ctxRec.fillStyle = '#9ca3af';
    ctxRec.font = '11px monospace';
    ctxRec.textAlign = 'right';
    ctxRec.fillText('+60c', 55, 16);
    ctxRec.textAlign = 'left';
    ctxRec.fillText('-60c', 65, 16);

    // Grille verticale et labels temps
    ctxRec.strokeStyle = '#22304f';
    ctxRec.lineWidth = 0.5;
    ctxRec.fillStyle = '#9ca3af';
    ctxRec.font = '10px monospace';
    ctxRec.textAlign = 'center';
    
    for (let sec = 0; sec <= 120; sec += 5) {
      const x = 60 + (w - 80) * (sec / 120);
      if (x < w - 20) {
        ctxRec.beginPath();
        ctxRec.moveTo(x, 0);
        ctxRec.lineTo(x, h);
        ctxRec.stroke();
        ctxRec.fillText(sec + 's', x, h - 4);
      }
    }
    debugLog_(`  ‚Üí Grille verticale + temps trac√©es`);

  } catch (err) {
    debugLog_(`‚ùå ERREUR drawCanvasRec: ${err.message}`);
    log('ERROR', 'drawCanvasRec: ' + err.message);
  }
}

function mapCentsToY(cents, height) {
  const centsPerPixel = 120 / (height - 80);
  const midY = height / 2;
  return midY - (cents / centsPerPixel);
}

function hzToCents(hz, ref = 440) {
  if (hz <= 0) return 0;
  return 1200 * Math.log2(hz / ref);
}

/* ==================== AUDIO INIT ==================== */
async function ensureAudio() {
  try {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      log('INFO', 'AudioContext cr√©√©');
      debugLog_(`‚úÖ AudioContext: sampleRate=${audioCtx.sampleRate}`);
    }
    if (audioCtx.state === 'suspended') {
      await audioCtx.resume();
      log('INFO', 'AudioContext repris');
      debugLog_(`‚úÖ AudioContext resum√©`);
    }
  } catch (err) {
    log('ERROR', 'AudioContext: ' + err.message);
    debugLog_(`‚ùå Erreur AudioContext: ${err.message}`);
    throw err;
  }
}

async function activateMic() {
  try {
    await ensureAudio();

    if (!micStream) {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log('INFO', 'Microphone autoris√©');
      debugLog_(`‚úÖ Microphone: ${micStream.getTracks().length} track(s)`);
    }

    if (!analyser) {
      const src = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      src.connect(analyser);
      log('INFO', 'Analyser connect√©');
      debugLog_(`‚úÖ Analyser: fftSize=${analyser.fftSize}, connected`);
    }

    btnMic.disabled = true;
    btnRecStart.disabled = false;

    if (!detector) initDetector();
    if (!smoother) initSmoother();

  } catch (err) {
    log('ERROR', 'Mic: ' + err.message);
    debugLog_(`‚ùå Mic error: ${err.message}`);
  }
}

/* ==================== PITCH DETECTION ==================== */
function initDetector() {
  try {
    if (typeof PitchyLite === 'undefined') {
      throw new Error('PitchyLite non disponible');
    }

    detector = new PitchyLite(audioCtx.sampleRate);
    log('INFO', 'D√©tecteur pitch (PitchyLite) initialis√©');
    debugLog_(`‚úÖ PitchyLite: pr√™t`);
    return true;
  } catch (err) {
    log('ERROR', 'initDetector: ' + err.message);
    debugLog_(`‚ùå initDetector: ${err.message}`);
    return false;
  }
}

/* ==================== PITCH SMOOTHER ==================== */
function initSmoother() {
  try {
    if (typeof PitchSmoother === 'undefined') {
      log('WARN', 'PitchSmoother non disponible');
      debugLog_(`‚ö†Ô∏è PitchSmoother: non disponible`);
      return false;
    }

    smoother = new PitchSmoother({
      medianWindowSize: 5,
      smoothingFactor: 0.7,
      maxPitchJump: 100,
      minConfidence: 0.3
    });
    log('INFO', 'PitchSmoother initialis√©');
    debugLog_(`‚úÖ PitchSmoother: initialis√©`);
    return true;
  } catch (err) {
    log('WARN', 'initSmoother: ' + err.message);
    debugLog_(`‚ö†Ô∏è initSmoother: ${err.message}`);
    return false;
  }
}

/* ==================== RECORDING ==================== */
function updateTimer(secs) {
  const mm = String(Math.floor(secs / 60)).padStart(2, '0');
  const ss = String(Math.floor(secs % 60)).padStart(2, '0');
  timerRec.textContent = `${mm}:${ss}`;
}

function startRecording() {
  try {
    if (!micStream) {
      log('WARN', 'Activez d\'abord le micro');
      return;
    }

    if (!detector) initDetector();
    if (!smoother) initSmoother();

    chunks = [];
    lastBlob = null;
    recordedPitch = [];
    recordDetectionCount = 0;
    recordDetectionRawCount = 0;
    pointsAddedTotal = 0;
    drawCallCount = 0;
    tickCallCount = 0;
    recStart = audioCtx.currentTime;

    debugLog_(`========== D√âBUT ENREGISTREMENT ==========`);
    debugLog_(`Heure: ${recStart.toFixed(3)}`);

    const options = {
      mimeType: 'audio/webm;codecs=opus',
      audioBitsPerSecond: 128000,
    };

    mediaRecorder = new MediaRecorder(micStream, options);
    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) {
        chunks.push(e.data);
      }
    };
    mediaRecorder.onstop = () => {
      if (chunks.length > 0) {
        lastBlob = new Blob(chunks, { type: 'audio/webm' });
        log('INFO', 'Enregistrement termin√©');
        debugLog_(`‚úÖ Enregistrement termin√©: ${lastBlob.size} bytes`);
      }
    };

    mediaRecorder.start(100);
    btnRecStart.disabled = true;
    btnRecStop.disabled = false;

    timerInterval = setInterval(() => {
      const elapsed = audioCtx.currentTime - recStart;
      updateTimer(elapsed);
    }, 100);

    log('INFO', 'Enregistrement d√©marr√©');
    startMonitor();
  } catch (err) {
    log('ERROR', 'startRecording: ' + err.message);
    debugLog_(`‚ùå startRecording: ${err.message}`);
  }
}

function stopRecording() {
  try {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      btnRecStart.disabled = false;
      btnRecStop.disabled = true;
      clearInterval(timerInterval);
      updateTimer(0);
      stopMonitor();
      
      debugLog_(`========== FIN ENREGISTREMENT ==========`);
      debugLog_(`Total tick() calls: ${tickCallCount}`);
      debugLog_(`Total draw() calls: ${drawCallCount}`);
      debugLog_(`Points ajout√©s: ${pointsAddedTotal}`);
      debugLog_(`recordedPitch.length: ${recordedPitch.length}`);
    }
  } catch (err) {
    log('ERROR', 'stopRecording: ' + err.message);
    debugLog_(`‚ùå stopRecording: ${err.message}`);
  }
}

/* ==================== MONITOR LIVE ==================== */
function startMonitor() {
  try {
    if (!detector || !analyser) {
      debugLog_(`‚ùå startMonitor: detector ou analyser manquant`);
      return;
    }
    if (rafId) {
      debugLog_(`‚ö†Ô∏è startMonitor: d√©j√† en cours`);
      return;
    }

    const buf = new Float32Array(analyser.fftSize);

    function tick() {
      tickCallCount++;
      
      // Chaque 30 ticks, afficher dans debugLog
      if (tickCallCount % 30 === 0) {
        debugLog_(`[TICK #${tickCallCount}] recordedPitch.length=${recordedPitch.length}`);
      }

      // Redessiner la base
      drawCanvasRec();

      // REDESSINER LA COURBE - C'EST L√Ä QUE √áA DOIT MARCHER!
      if (recordedPitch.length > 0) {
        debugLog_(`[DRAW-CURVE #${drawCallCount}] ${recordedPitch.length} points √† tracer`);

        ctxRec.strokeStyle = '#3b82f6';
        ctxRec.lineWidth = 2.5;
        ctxRec.lineJoin = 'round';
        ctxRec.lineCap = 'round';
        ctxRec.beginPath();

        for (let i = 0; i < recordedPitch.length; i++) {
          const p = recordedPitch[i];
          
          // Log les premiers et derniers points
          if (i === 0 || i === recordedPitch.length - 1) {
            debugLog_(`  ‚Üí Point[${i}]: x=${p.x.toFixed(1)}, y=${p.y.toFixed(1)}, cents=${p.cents.toFixed(1)}`);
          }

          if (i === 0) {
            ctxRec.moveTo(p.x, p.y);
          } else {
            ctxRec.lineTo(p.x, p.y);
          }
        }

        debugLog_(`  ‚Üí Appel ctxRec.stroke() avec couleur #3b82f6, width=2.5`);
        ctxRec.stroke();

        // Tracer les points
        ctxRec.fillStyle = '#3b82f6';
        for (const p of recordedPitch) {
          ctxRec.beginPath();
          ctxRec.arc(p.x, p.y, 2, 0, Math.PI * 2);
          ctxRec.fill();
        }
        
        debugLog_(`  ‚úÖ Courbe trac√©e (${recordedPitch.length} points + cercles)`);
      } else {
        if (tickCallCount % 30 === 0) {
          debugLog_(`‚ö†Ô∏è recordedPitch vide, pas de courbe`);
        }
      }

      // D√©tecter le pitch et ajouter un nouveau point
      try {
        analyser.getFloatTimeDomainData(buf);
        const hz = detector.detect(buf);

        if (hz && hz > 0) {
          recordDetectionRawCount++;

          let smoothedHz = hz;
          if (smoother) {
            smoothedHz = smoother.smooth(hz);
          }

          // ‚úÖ FIX: Utiliser smoothedHz OU hz brut si smoother retourne null
          const finalHz = smoothedHz || hz;
          
          if (finalHz && finalHz > 0) {
            const cents = hzToCents(finalHz, 440);
            const elapsed = audioCtx.currentTime - recStart;
            const x = 60 + (canvasRec.width - 80) * Math.min(elapsed / 120, 1);
            const y = mapCentsToY(cents, canvasRec.height);

            recordedPitch.push({ t: elapsed, hz: finalHz, cents, x, y });
            recordDetectionCount++;
            pointsAddedTotal++;

            // Log toutes les 10 d√©tections
            if (recordDetectionCount % 10 === 0) {
              debugLog_(`  ‚Üí D√©tection #${recordDetectionCount}: hz=${finalHz.toFixed(1)}, x=${x.toFixed(1)}, y=${y.toFixed(1)}`);
            }
          }
        }
      } catch (err) {
        debugLog_(`‚ùå ERREUR tick detection: ${err.message}`);
      }

      debugRec.textContent = `Brutes: ${recordDetectionRawCount} | Liss√©s: ${recordDetectionCount} | Pts canvas: ${recordedPitch.length}`;

      if (mediaRecorder && mediaRecorder.state === 'recording') {
        rafId = requestAnimationFrame(tick);
      }
    }

    tick();
    debugLog_(`‚úÖ startMonitor: requestAnimationFrame lanc√©`);
  } catch (err) {
    log('ERROR', 'startMonitor: ' + err.message);
    debugLog_(`‚ùå startMonitor: ${err.message}`);
  }
}

function stopMonitor() {
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }
  drawCanvasRec();
}

/* ==================== EVENTS ==================== */
btnMic.onclick = () => activateMic();
btnRecStart.onclick = () => startRecording();
btnRecStop.onclick = () => stopRecording();
btnClearRec.onclick = () => {
  try {
    chunks = [];
    lastBlob = null;
    recordedPitch = [];
    recordDetectionCount = 0;
    recordDetectionRawCount = 0;
    pointsAddedTotal = 0;
    updateTimer(0);
    drawCanvasRec();
    debugRec.textContent = 'Brutes: 0 | Liss√©s: 0 | Pts canvas: 0';
    debugLog_(`üóëÔ∏è Canvas effac√©`);
    log('INFO', 'Enregistrement effac√©');
  } catch (err) {
    log('ERROR', 'Clear rec: ' + err.message);
  }
};

log('INFO', '‚úÖ Interface DEBUG pr√™te');
debugLog_(`‚úÖ DEBUG MODE ACTIF - Logs pr√©cis du rendu`);
</script>

</body>
</html>
